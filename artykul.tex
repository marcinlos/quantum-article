\documentclass[10pt]{article}



\usepackage[utf8]{inputenc}
\usepackage{lmodern} 
\usepackage[T1]{fontenc}
\usepackage{microtype}

%\usepackage[pdftex]{graphicx}
%\usepackage[pdftex]{hyperref} 
%\usepackage{bookmark}
\usepackage{url}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{polski}
\usepackage[polish]{babel}

\usepackage{csagh}

\begin{document}
\begin{opening}

\title{Quantum Commitment}
\author[AGH University of Science and Technology, los@student.agh.edu.pl]{Marcin Łoś}

\begin{abstract}
  W sumie nic takiego, parę artykułów pocytowane i tyle.
\end{abstract}

\keywords{quantum commitment}

\end{opening}

\section{What is a commitment scheme?} 

A commitment scheme is a cryptographic protocol that allows one (henceforth known as ,,Alice'') to make a
permanent choice (\emph{commitment}), and provide a prove of this fact to other parties (henceforth known
as ,,Bob''), without immediately revealing the choosen value, while at the same time making it possible 
for Alice to reveal it later in such a way that Bob can verify it is indeed the value Alice has choosen 
initially. Hence, there are two basic goals of a commitment scheme:

\begin{itemize}
  \item \emph{concealing} -- the proof must not provide Bob with information sufficient to determine the
    choosen value. This is necessary to ensure safety of Alice -- secrecy of her choice.
  \item \emph{binding} -- the proof must provide Bob with information sufficient to check if a particular
    value is the value choosen by Alice. This is necessary to ensure safety of Bob -- simply speaking,
    Alice must not be able to ,,cheat'', i.e. to make Bob believe she has choosen a value different than
    the one she actually has.
\end{itemize}

Intuitively, there seems to be a tradeoff between these two properties -- on the one hand, empty proof
is perfectly concealing, but does not bind Alice in any way, and revealing the full value is perfectly
binding, while obviously not concealing.


Usually, commitment schemes consist of two phases:

\begin{itemize}
  \item \emph{commitment phase} -- Alice chooses the value, and produces a proof for Bob
  \item \emph{reveal phase} -- Alice reveals choosen value to Bob, who verifies it using his proof
\end{itemize}

As it turns out, commitment schemes constitute a rich and important branch of cryptography, with lots of
applications both practical and theoretical, as building blocks for other protocols. One simple example,
motivating the need for such device, and showing naturally arising problems it solves, is a game of 
rock-paper-scissor. Two people form one of three shapes with their palm, and simultaneously display it
to one another. Their choices determine the outcome -- one of them wins, or there is a draw. In the
language of commitment schemes, used above, two people commit to one of 3 possible values, and then reveal
their choice. It is vital that neither knows the choice of the other before he makes his own, otherwise
he could always choose a winning shape, and inevitably win every time, rendering the game pointless.
This illustrates the need for concealing -- the choice must be secret. In practice, this is ensured
by forming the shape keeping the hand behind one's back. Furthermore, it must not be possible to change
the value after commitment. Otherwise, after one of the players reveals his choice, the other could again
switch to winning shape. In practice, players reveals their values simultaneously, thus in principle it
should not be possible to cheat.\footnotemark

\footnotetext{
Of course, someone with superhuman reflexes and perception could still manage to switch sufficiently 
fast, so it is, in principle, neither concealing, nor binding -- it's an inherent theoretical security
flow. With a proper commitment scheme, there is no such problem, as long as both players commit to their
choice before the reveal phase.
}


\section{Commitment schemes in modern cryptography}

In this section, we shall explore briefly some of the applications of commitment schemes in various
areas of cryptography, to provide further motivation and emphasize importance of the subject.

\subsection{Zero-knowledge proofs}

Zero-knowledge proof (protocol) is a method of proving some statement without revealing anything more
than what is required to verify the proof. The problem bears resemblance to the commitment problem, but
is more general. Nice introduction to the subject, with motivating examples and precise definitions can
be found in the first two chapters of \cite{MIT:StatZero}. 

Common special case is proving that one possesses some information without revealing it.
One simple example comes from asymmetric cryptography: if Alice posesses the private key matching Bob's
public key, she can prove it to Bob in the following manner: Bob chooses a random string, encrypts it
with the public key, and sends it to Alice, who subseqnently uses her private key to decrypt the message,
and sends the plaintext to Bob. Assuming security of choosen encryption algorithm, Bob can conclude 
with high probability that if the plaintext matches his original encrypted message, Alice does indeed
possess the private key. Furthermore, if Alice does not have the private key, she has no way to obtain
the plaintext, short of breaking the encryption.

Commitment schemes often prove useful as building blocks of zero-knowledge protocols. Well-known example
is a way for Alice to prove she knows the Hamiltonian cycle in certain graph, without revealing the
cycle. Detailed discussion and analysis can be found in the first section of \cite{CM:CryptoNotes}. 
Let \(G\) be the graph. The protocol consists of following steps:

\begin{enumerate}
  \item Alice chooses some graph \(G'\) isomorphic to \(G\) and isomorphism \(\sigma\colon G\cong G'\)
  \item Alice commits to her choice
  \item Bob can now ask Alice for one of two things:
    \begin{enumerate}
      \item graph \(G'\) and isomorphism \(\sigma\)
      \item image of Alice's hamiltonian cycle by \(\sigma\), i.e. hamiltonian cycle in \(G'\)
    \end{enumerate}
  \item Bob verifies the answer, depending on the question
\end{enumerate}

If Alice can consistently produce acceptable responses to Bob's questions, he can conclude with high
probability that she has indeed found the hamiltonian cycle in \(G\). Otherwise, she would either fail
to exhibit isomorphism between \(G\) and her choosen graph \(G'\), even if she knew a hamiltonian
cycle in \(G'\), or she wouldn't be able to find hamiltonian cycle in \(G'\), even if she knew an
isomorphism \(G\cong G'\). At the same time, Bob learns nothing about the cycle in \(G\), since he
either gets the isomorphism and no cycle, or he gets cycle in some graph \(G'\neq G\), but without
full knowledge of \(G'\) and the isomorphism he cannot pull it back to \(G\).
\footnote{Even with full knowledge of \(G'\) he cannot easily find an isomorphism by himself, as no
polynomial algorithm for Graph Isomorphism Problem is known.}


\subsection{Secret sharing}

Secret sharing is a problem of distributing parts of an information (,,secret'') among a group of
entities (,,players''), such that some number of parts, bounded from below, is necessary to 
reconstruct the full information. A vivid example from popular culture is the concept that usage
of mass-destruction weapons, e.g. nuclear missles, requires authorization and ,,launch codes'' of
two people, to increase security and prevent usage by malicious third parties, that might be able
to obtain one part of such ,,secret''.

There are quite a few known approaches, ranging from relatively easy, like Shamir's scheme, where
the secret is a polynomial, and shares are its' values for some arguments (the secret is reconstructed
as a unique interpolation through such points), or Blakley's scheme (secret is a point in euclidean
space, shares are hyperplanes, such that the point is their intersection) \footnotemark, through more
complicated, more general constructions (albeit, perhaps a bit surprisingly, still largely based on linear
algebra over Galois fields), to relatively new non-linear schemes \cite{Beimel01onthe}. For an overview 
of the subject see \cite{SharingSurvey}.

\footnotetext{The principle is actually the same as in Shamir's scheme, since in both cases the
fundamental idea is distributing parts of system of linear equations. There is an important difference,
though -- shares in Shamir's scheme are constant, while in Blakley's scheme they grow linearly with
the number of participants, unless some restrictions on the hyperplanes are placed.}


The variant of the problem where commitment schemes found use is known as verifiable secret sharing.
In the standard formulation, participants are assumed to be honest, and carry out the protocol correctly.
If this is not the case, it becomes critical that players can verify their own and each other's shares'
validity. Possible realization of verifiable secret sharing consists of distributing publicly proofs
(certificates) of the shares, so that each share can be verified by anyone that possesses it. Such
protocols can be used to construct \emph{simultaneous broadcast networks}. See \cite{VerifiableSharing}
for details and example algorithm. 
\footnote{Which, by the way, utilizes the concept of oblivious transfer, discussed in one of the next
sections}

\subsection{Secure multiparty computation}

Closely related to secret sharing is the problem of secure multiparty computation, where participants
want to calculate value of a function for an input constructed from their partial inputs, without
revealing their partial inputs to each other. Canonical example of such situation is the \emph{milionaire
problem}, described in one of the first papers on the subject \cite{Yao}: two milionaires wish to
know which one is richer, but they are reluctant to reveal their net worth. Needless to say, multiparty
computation has many more practical applications, like negotiations, voting or auctions \cite{grigoriev}.

As it turns out, secure computation is feasible for a very large class of functions, as was shown in
\cite{Goldreich87}, where an effective algorithm for creating a secure protocol based on the description
of the computation has been presented. In \cite{Chaum88} another, slightly more general approach has
been proposed. In both cases, commitment schemes are utilized to ensure correctness of computation in
presence of sufficiently small number of malicious participants by means of verifiable secret sharing. 

\subsection{Oblivious transfer}

Oblivious transfer protocol is a way to transmit information from sender to receiver in such a way,
that the sender does not know what precisely did he send, in particular -- if he sent anything at all.
This seemingly weird concept, introduced in \cite{Rabin81}, turns out to be of fundamental importance.

Original context in which it appeared was an algorithm for exchange of secrets: Alice and Bob have some
values, and they want to exchange it, so that no party can withdraw from the protocol after obtaining
the secret of the other, before giving away its' own secret. With certain assumptions, the problem
can be solved with oblivious transfer. The basic idea of the protocol described in \cite{Rabin81} is:

\begin{itemize}
  \item it can fail -- it's possible that after completing the protocol, neither side knows 
    the other's secret
  \item at the end of the protocol, Bob knows whether or not he has obtained Alice's secret
  \item it is assumed that Alice can always find out whether Bob has obtained the secret
  \item Alice knows Bob's secret iff Bob has received her secret
\end{itemize}

The algorithm is not perfect -- in particular, when Alice receives one of the Bob's messages, before
she sends anything important to Bob, she knows Bob's secret with probability \(\frac{1}{2}\). More
important than the algorithm itself, though, is the idea of distributing information without learning
the state of knowledge of the recipient. In particular, secure oblivious transfer protocol is enough
to solve secure multiparty computation problem \cite{Kilian88}. In the classical setting, bit commitment
is strictly weaker primitive than oblivious transfer \cite{Brassard88}. In the quantum setting, however,
bit commitment has been proven sufficient to build secure oblivious transfer protocol 
\cite{Crepeau88,Bennet92,Yao95,Damgard09}.
\footnotemark

\footnotetext{Also, oblivious transfer can be used to create bit commitment protocol, hence these two
problems are equivalent in quantum setting. Sadly, it implies unconditionally secure oblivious transfer
is impossible, as it has been proven there can be no unconditionally secure quantum bit commitment
protocols \cite{Mayers97,Brassard97,Lo98,Chiribella2013}} 


\section{Classical commitment protocols}

In this section, we shall take a brief look at few classical approaches to the commitment problem,
and try to identify their shortcomings. Of course, by no means does the following discussion aim
to be a complete survey of the field. Its sole purpose is to give a general idea what kind of 
techniques are commonly used. For more information, see e.g. \cite{Brassard88,Naor91,Naor98,Damgard02}.

One fundamental issue with all the classical protocols, consisting of simple exchange of messages,
is that they cannot provide perfect, unconditional security to both Bob and Alice. As we shall see,
there are perfectly hiding protocols, and perfectly concealing protocols, but not both. These two
goals seem to be conflicting -- concealing requires ,,weak'' proof, while binding needs it to be
sufficiently ,,strong''.

Without precise mathematical framework it's impossible to provide a rigorous proof, but it's possible 
to give a (more or less) convincing argument. For simplicity, let us consider the case of bit 
commitment, where the commited information is a single bit. Suppose there is such protocol. Commitment 
proof \(c\) is created from some information \(r\), known only to the commiter, and the commited value 
\(v\in\{0,1\}\). That is, \(c=\phi(r,v)\). Since the protocol is perfectly concealing, there must
be \(r'\) such that \(\phi(r,v)=\phi(r',1-v)\), otherwise \(c\) carries full information about \(v\),
and Bob, having unlimited computational resources, can determine \(v\). But then, Alice, having 
unlimited computational resources as well, can find such \(r'\), and during the reveal phase present 
Bob with \(r', 1-v\) instead of \(r, v\), thus changing her commitment.
\footnote{This reasoning does not apply to quantum protocols, due to their fundamentally different
nature. The conclusion is still true, unfortunately, but the proof is quite different.}

\subsection*{Protocol based on Graph Isomorphism Problem}

Let \(G\) and \(H\) be isomorphic graphs, provided by Bob. Suppose Alice wants to commit to value 0
or 1. To do this, she creates a graph \(F\) isomorphic to \(G\) if her choice is 0, and isomorphic 
to \(H\) otherwise (for example, by randomly permuting the vertices), and presents it to Bob. Later,
if she wants reveal the value and prove she has commited to it (open a commitment), she exhibits 
isomorphism between \(F\) and \(G\) or \(H\), depending on her choice.

Security of this algorithm depends on two assumptions:

\begin{itemize}
  \item it is computationally infeasible for Alice to find isomorphism between the graphs used in the
    protocol
  \item Alice is certain that \(G\) and \(H\) are indeed isomorphic, even though she doesn't know
    the isomorphism
\end{itemize}

First assumption is (almost) enough to provide practical security. Alice cannot cheat, since that would
require finding an isomorphism between \(F\) and one of \(G\), \(H\) different than the one she used to
create \(F\). She cannot create graph such that she knows isomorphisms with both \(G\) and \(H\), since
that would yield an isomorphism between \(G\) and \(H\). Furthermore, Bob, regardless of computational
power, cannot extract any information from \(F\), as it's isomorphic to both \(G\) and \(H\). The only 
way for Bob to cheat is to provide graphs \(G\), \(H\) which are not isomorphic. Then, if he possesses
sufficient resources, he can learn the value of Alice's bit by finding an isomorphism between \(F\) and
one of \(G\), \(H\).

From the above discussion, we can see that if the two assumptions are satisfied, the algorithm is
perfectly concealing (Bob does not gain any information whatsoever), and binding if Alice cannot solve
the graph isomorphism problem.

This is one of the oldest and simplest proposed algorithms, presented as an ,,elementary example'' 
in the original paper that actually defined the notion of commitment scheme \cite{Brassard88}, and 
used it as a primitive to construct zero-knowledge protocols.

\subsection*{Protocol based on Discrete Logarithm Problem}

Let \(p\) be a prime number, \(\mathbb{F}_p=\mathbb{Z}/p\mathbb{Z}\). It is well-known that 
\(\mathbb{F}_p\) is a field, and that multiplicative subgroup of a finite field is cyclic, hence it
has a generator. At the beginning of the protocol, Alice and Bob choose \(p\) and \(\alpha\), some
generator of \(\mathbb{F}^*_p\). Let \(u\) be the smallest integer such that \(2^u \nmid p-1\). 
Then, Alice chooses random \(0\leq y < p-1\) such that \(u\)-th bit of \(y\) is equal to the bit
she wishes to commit to\footnotemark, and calculates \(x\equiv \alpha^y \mod p\), which she gives
to Bob as the commitment proof. During the reveal phase, she presents Bob with \(y\).

The algorithm is concealing, assuming Bob does not possess sufficient computational resources to
calculate the discrete logarithm. On the other hand, it's perfectly binding -- since \(\alpha\) is
a generator of \(\mathbb{F}_p\), for any \(x\in\mathbb{F}_p\) there exists unique \(0\leq y < p-1\)
such that \(x\equiv \alpha^y \mod p\), thus Alice cannot change the commited value, regardless
of her computational resources.



\footnotetext{
Concealing property of this algorithm relies on the difficulty of computing discrete logarithm.
However, while obtaining the whole value is infeasible, some bits of the result can be easily 
determined, hence some care must be taken to avoid placing secret bit in this range. See 
\cite{Brassard88} for details and references.
}

\subsection*{Protocol based on one-way permutation} 

Another protocol utlizes concept of one-way permutation. Intuitively, it is a easy to compute
bijection \(\sigma\colon \{1\ldots n\}\rightarrow \{1\ldots n\}\), such that calculating the
inverse is computationally infeasible \footnotemark. Let \(\langle a,b\rangle\) denote standard
inner product in \(\mathbb{F}_2^n\), and \(b\in\{0,1\}\) be the value Alice wishes to commit to.
The protocol consists of the following steps:

\footnotetext{This can be made precise. See \cite{Naor98} for details} 

\begin{enumerate}
  \item Alice and Bob choose one-way permutation \(\sigma\colon \mathbb{F}_2^n\rightarrow 
    \mathbb{F}_2^n\)
  \item Alice chooses random vector \(x\in\mathbb{F}_2^n\), and calculates \(y=\sigma(x)\)
  \item Bob chooses \((n-1)\) linearly independent vectors \(h_i\in\mathbb{F}_2^n\), 
    \(i=1,\ldots, n-1\)
  \item Bob sends them to Alice, who computes \(c_i=\langle h_i, y\rangle\) and sends the results to Bob
  \item Solutions to system of equations \(\langle h_i, X\rangle = c_i\) form one-dimensional
    affine subspace of \(\mathbb{F}_2^n\), consisting of two elements, \(y_0\) and \(y_1\). Alice
    and Bob compute these solutions.\footnotemark
  \item Let \(c\) be such that \(y_c = y\). Alice sends to Bob \(d=b\oplus c\)
\end{enumerate}

Reveal phase consists of Alice sending \(b\) and \(x\) to Bob, who computes \(y=f(x)\) and verifies
the data obtained previously from Alice.

Concealing is relatively easy to show, it follows from the fact that regardless of \(b\), distribution
of the information possessed by Bob, i.e. \(h_i\), \(c_i\) and \(d\) is the same. The scheme is thus
perfectly concealing. It is also computationally binding. The proof, however, is rather involved, and 
thus ommited. Details can be found in \cite{Naor98}.


\footnotetext{They need to agree which one is \(y_0\), and which one is \(y_1\). One way to achieve
this is to fix an total order on \(\mathbb{F}_2^n\), e.g. lexicographical, and let \(y_0\) denote the
smaller solution.}

\section{What does the quantum mechanics bring to the table?}

Predictions of quantum mechanics, over the decades, has been considered by many as defying our intuitive
grasp of reality, if not the nature of the universe itself. Principles governing quantum world seem to
strongly deviate from those of the macroscopic world we observe every day, hence it seems concievable
that, given such vastly different rules, certain problems unsolvable in the classical setting, can be
solved within this new framework. Strong connections with information theory are readily apparent -- 
different nature of the information itself (qubit vs classical bit), of its storage (e.g. no-cloning 
theorem), of the measurement process (e.g. wave function collapse), inherent probabilistic aspects --
all of this could be seen as a promise of a new, rich breeding ground for ideas and technologies
capable of achieving things previously deemed impossible. Given the fundamental limitations and flaws
of classical cryptographical protocols, a natural question arises: can quantum mechanics do better?

\subsection*{Success of Quantum Key Distribution}

Possibly the most significant advances in quantum cryptography have been made in the area of Quantum
Key Distribution (QKD). Key distribution is a problem where two parties wish to produce shared secret
key. Probably the most spectacular application of perfectly secure key distribution protocol is the
fact it makes one-time pad encryption (proven by Shannon to be perfectly secure) practically possible.
Classicaly, one-time pad, although of theoretical interest, was not considered usable, since the
key needs to be the same size as the message to be encrypted with it, and still needs to be somehow 
securely transmitted, which does not seem to be significantly easier than transmitting the message
itself.

Nevertheless, unique features of quantum mechanics (namely, destructiveness of measurment process)
allowed  for creating distribution protocols such that any eavesdropping third-party can be detected,
so if the key is compromised, communicating parties are aware of that \cite{bb84}. Although the
theoretical versions of such protocols are proven to be secure, practical considerations facilitate
certain types of attacks (e.g. most proofs assume the information is carried by a single photon,
which is rather technically challenging constraint). Nevertheless, over time more and more refined
protocols have been devised, improving safety and efficiency. It doesn't seem to be an exaggeration 
to say that the state of the art, both theoretical and practical, is impressive.


\section{Summary}

\nocite{*}

\bibliographystyle{cs-agh}
\bibliography{bibliography}

\end{document}
