\documentclass[10pt]{article}

\usepackage{csagh}

\usepackage[utf8]{inputenc}
\usepackage{lmodern} 
\usepackage[T1]{fontenc}
\usepackage{microtype}

%\usepackage[pdftex]{graphicx}
%\usepackage[pdftex]{hyperref} 
%\usepackage{bookmark}
\usepackage{url}

\usepackage{polski}
\usepackage[polish]{babel}


\begin{document}
\begin{opening}

\title{Quantum Commitment}
\author[AGH University of Science and Technology, los@student.agh.edu.pl]{Marcin Łoś}

\begin{abstract}
  W sumie nic takiego, parę artykułów pocytowane i tyle.
\end{abstract}

\keywords{quantum commitment}

\end{opening}

\section{What is a commitment scheme?}

A commitment scheme is a cryptographic protocol that allows one (henceforth known as ,,Alice'') to make a
permanent choice (\emph{commitment}), and provide a prove of this fact to other parties (henceforth known
as ,,Bob''), without immediately revealing the choosen value, while at the same time making it possible 
for Alice to reveal it later in such a way that Bob can verify it is indeed the value Alice has choosen 
initially. Hence, there are two basic goals of a commitment scheme:

\begin{itemize}
  \item \emph{concealing} -- the proof must not provide Bob with information sufficient to determine the
    choosen value. This is necessary to ensure safety of Alice -- secrecy of her choice.
  \item \emph{binding} -- the proof must provide Bob with information sufficient to check if a particular
    value is the value choosen by Alice. This is necessary to ensure safety of Bob -- simply speaking,
    Alice must not be able to ,,cheat'', i.e. to make Bob believe she has choosen a value different than
    the one she actually has.
\end{itemize}

Intuitively, there seems to be a tradeoff between these two properties -- on the one hand, empty proof
is perfectly concealing, but does not bind Alice in any way, and revealing the full value is perfectly
binding, while obviously not concealing.


Usually, commitment schemes consist of two phases:

\begin{itemize}
  \item \emph{commitment phase} -- Alice chooses the value, and produces a proof for Bob
  \item \emph{reveal phase} -- Alice reveals choosen value to Bob, who verifies it using his proof
\end{itemize}

As it turns out, commitment schemes constitute a rich and important branch of cryptography, with lots of
applications both practical and theoretical, as building blocks for other protocols. One simple example,
motivating the need for such device, and showing naturally arising problems it solves, is a game of 
rock-paper-scissor. Two people form one of three shapes with their palm, and simultaneously display it
to one another. Their choices determine the outcome -- one of them wins, or there is a draw. In the
language of commitment schemes, used above, two people commit to one of 3 possible values, and then reveal
their choice. It is vital that neither knows the choice of the other before he makes his own, otherwise
he could always choose a winning shape, and inevitably win every time, rendering the game pointless.
This illustrates the need for concealing -- the choice must be secret. In practice, this is ensured
by forming the shape keeping the hand behind one's back. Furthermore, it must not be possible to change
the value after commitment. Otherwise, after one of the players reveals his choice, the other could again
switch to winning shape. In practice, players reveals their values simultaneously, thus in principle it
should not be possible to cheat.\footnotemark

\footnotetext{
Of course, someone with superhuman reflexes and perception could still manage to switch sufficiently 
fast, so it is, in principle, neither concealing, nor binding -- it's an inherent theoretical security
flow. With a proper commitment scheme, there is no such problem, as long as both players commit to their
choice before the reveal phase.
}


\section{Commitment schemes in modern cryptography}

In this section, we shall explore briefly some of the applications of commitment schemes in various
areas of cryptography, to provide further motivation and emphasize importance of the subject.

\subsection{Zero-knowledge proofs}

Zero-knowledge proof (protocol) is a method of proving some statement without revealing anything more
than what is required to verify the proof. The problem bears resemblance to the commitment problem, but
is more general. Nice introduction to the subject, with motivating examples and precise definitions can
be found in the first two chapters of \cite{MIT:StatZero}. 

Common special case is proving that one possesses some information without revealing it.
One simple example comes from asymmetric cryptography: if Alice posesses the private key matching Bob's
public key, she can prove it to Bob in the following manner: Bob chooses a random string, encrypts it
with the public key, and sends it to Alice, who subseqnently uses her private key to decrypt the message,
and sends the plaintext to Bob. Assuming security of choosen encryption algorithm, Bob can conclude 
with high probability that if the plaintext matches his original encrypted message, Alice does indeed
possess the private key. Furthermore, if Alice does not have the private key, she has no way to obtain
the plaintext, short of breaking the encryption.

Commitment schemes often prove useful as building blocks of zero-knowledge protocols. Well-known example
is a way for Alice to prove she knows the Hamiltonian cycle in certain graph, without revealing the
cycle. Detailed discussion and analysis can be found in the first section of \cite{CM:CryptoNotes}. 
Let \(G\) be the graph. The protocol consists of following steps:

\begin{enumerate}
  \item Alice chooses some graph \(G'\) isomorphic to \(G\) and isomorphism \(\sigma\colon G\cong G'\)
  \item Alice commits to her choice
  \item Bob can now ask Alice for one of two things:
    \begin{enumerate}
      \item graph \(G'\) and isomorphism \(\sigma\)
      \item image of Alice's hamiltonian cycle by \(\sigma\), i.e. hamiltonian cycle in \(G'\)
    \end{enumerate}
  \item Bob verifies the answer, depending on the question
\end{enumerate}

If Alice can consistently produce acceptable responses to Bob's questions, he can conclude with high
probability that she has indeed found the hamiltonian cycle in \(G\). Otherwise, she would either fail
to exhibit isomorphism between \(G\) and her choosen graph \(G'\), even if she knew a hamiltonian
cycle in \(G'\), or she wouldn't be able to find hamiltonian cycle in \(G'\), even if she knew an
isomorphism \(G\cong G'\). At the same time, Bob learns nothing about the cycle in \(G\), since he
either gets the isomorphism and no cycle, or he gets cycle in some graph \(G'\neq G\), but without
full knowledge of \(G'\) and the isomorphism he cannot pull it back to \(G\).
\footnote{Even with full knowledge of \(G'\) he cannot easily find an isomorphism by himself, as no
polynomial algorithm for Graph Isomorphism Problem is known.}


\subsection{Secret sharing}

Secret sharing is a problem of distributing parts of an information (,,secret'') among a group of
entities (,,players''), such that some number of parts, bounded from below, is necessary to 
reconstruct the full information. A vivid example from popular culture is the concept that usage
of mass-destruction weapons, e.g. nuclear missles, requires authorization and ,,launch codes'' of
two people, to increase security and prevent usage by malicious third parties, that might be able
to obtain one part of such ,,secret''.

There are quite a few known approaches, ranging from relatively easy, like Shamir's scheme, where
the secret is a polynomial, and shares are its' values for some arguments (the secret is reconstructed
as a unique interpolation through such points), or Blakley's scheme (secret is a point in euclidean
space, shares are hyperplanes, such that the point is their intersection) \footnotemark, through more
complicated, more general constructions (albeit, perhaps a bit surprisingly, still largely based on linear
algebra over Galois fields), to relatively new non-linear schemes \cite{Beimel01onthe}. For an overview 
of the subject see \cite{SharingSurvey}.

\footnotetext{The principle is actually the same as in Shamir's scheme, since in both cases the
fundamental idea is distributing parts of system of linear equations. There is an important difference,
though -- shares in Shamir's scheme are constant, while in Blakley's scheme they grow linearly with
the number of participants, unless some restrictions on the hyperplanes are placed.}


The variant of the problem where commitment schemes found use is known as verifiable secret sharing.
In the standard formulation, participants are assumed to be honest, and carry out the protocol correctly.
If this is not the case, it becomes critical that players can verify their own and each other's shares'
validity. Possible realization of verifiable secret sharing consists of distributing publicly proofs
(certificates) of the shares, so that each share can be verified by anyone that possesses it. Such
protocols can be used to construct \emph{simultaneous broadcast networks}. See \cite{VerifiableSharing}
for details and example algorithm. 
\footnote{Which, by the way, utilizes the concept of oblivious transfer, discussed in one of the next
sections}

\subsection{Secure multiparty computation}

Closely related to secret sharing is the problem of secure multiparty computation, where participants
want to calculate value of a function for an input constructed from their partial inputs, without
revealing their partial inputs to each other. Canonical example of such situation is the \emph{milionaire
problem}, described in one of the first papers on the subject \cite{Yao}: two milionaires wish to
know which one is richer, but they are reluctant to reveal their net worth. Needless to say, multiparty
computation has many more practical applications, like negotiations, voting or auctions \cite{grigoriev}.

As it turns out, secure computation is feasible for a very large class of functions, as was shown in
\cite{Goldreich87}, where an effective algorithm for creating a secure protocol based on the description
of the computation has been presented. In \cite{Chaum88} another, slightly more general approach has
been proposed. In both cases, commitment schemes are utilized to ensure correctness of computation in
presence of sufficiently small number of malicious participants by means of verifiable secret sharing. 

\subsection{Oblivious transfer}

Oblivious transfer protocol is a way to transmit information from sender to receiver in such a way,
that the sender does not know what precisely did he send, in particular -- if he sent anything at all.
This seemingly weird concept, introduced in \cite{Rabin81}, turns out to be of fundamental importance.

Original context in which it appeared was an algorithm for exchange of secrets: Alice and Bob have some
values, and they want to exchange it, so that no party can withdraw from the protocol after obtaining
the secret of the other, before giving away its' own secret. With certain assumptions, the problem
can be solved with oblivious transfer. The basic idea of the protocol described in \cite{Rabin81} is:

\begin{itemize}
  \item it can fail -- it's possible that after completing the protocol, neither side knows 
    the other's secret
  \item at the end of the protocol, Bob knows whether or not he has obtained Alice's secret
  \item it is assumed that Alice can always find out whether Bob has obtained the secret
  \item Alice knows Bob's secret iff Bob has received her secret
\end{itemize}

The algorithm is not perfect -- in particular, when Alice receives one of the Bob's messages, before
she sends anything important to Bob, she knows Bob's secret with probability \(\frac{1}{2}\). More
important than the algorithm itself, though, is the idea of distributing information without learning
the state of knowledge of the recipient. In particular, secure oblivious transfer protocol is enough
to solve secure multiparty computation problem \cite{Kilian88}. In the classical setting, bit commitment
is strictly weaker primitive than oblivious transfer. In the quantum setting, however, bit commitment
has been proven sufficient to build secure oblivious transfer protocol \cite{Bennet92,Yao95,Damgard09}.
\footnotemark

\footnotetext{Also, oblivious transfer can be used to create bit commitment protocol, hence these two
problems are equivalent in quantum setting. Sadly, it implies unconditionally secure oblivious transfer
is impossible, as it has been proven there can be no unconditionally secure quantum bit commitment
protocols \cite{Mayers97,Brassard97,Lo98,Chiribella2013}} 


\section{Classical commitment protocols}

In this section, we shall take a brief look at the classical approaches to the commitment problem,
and try to identify their shortcomings.


\nocite{*}

\bibliographystyle{cs-agh}
\bibliography{bibliography}

\end{document}
