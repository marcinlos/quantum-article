\documentclass[10pt]{article}



\usepackage[utf8]{inputenc}
\usepackage{lmodern} 
\usepackage[T1]{fontenc}
\usepackage{microtype}

%\usepackage[pdftex]{graphicx}
%\usepackage[pdftex]{hyperref} 
%\usepackage{bookmark}
\usepackage{url}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{braket}
\usepackage[ruled]{algorithm2e}

\usepackage{polski}
\usepackage[polish]{babel}

\usepackage{csagh}

\newtheorem{theorem}{Theorem}

\begin{document}
\begin{opening}

\title{Quantum Commitment}
\author[AGH University of Science and Technology, los@student.agh.edu.pl]{Marcin Łoś}

\begin{abstract}
  W sumie nic takiego, parę artykułów pocytowane i tyle.
\end{abstract}

\keywords{quantum commitment}

\end{opening}

\section{What is a commitment scheme?} 

A commitment scheme is a cryptographic protocol that allows one (henceforth known as ,,Alice'') to make a
permanent choice (\emph{commitment}), and provide a prove of this fact to other parties (henceforth known
as ,,Bob''), without immediately revealing the choosen value, while at the same time making it possible 
for Alice to reveal it later in such a way that Bob can verify it is indeed the value Alice has choosen 
initially. Hence, there are two basic goals of a commitment scheme:

\begin{itemize}
  \item \emph{concealing} -- the proof must not provide Bob with information sufficient to determine the
    choosen value. This is necessary to ensure safety of Alice -- secrecy of her choice.
  \item \emph{binding} -- the proof must provide Bob with information sufficient to check if a particular
    value is the value choosen by Alice. This is necessary to ensure safety of Bob -- simply speaking,
    Alice must not be able to ,,cheat'', i.e. to make Bob believe she has choosen a value different than
    the one she actually has.
\end{itemize}

Intuitively, there seems to be a tradeoff between these two properties -- on the one hand, empty proof
is perfectly concealing, but does not bind Alice in any way, and revealing the full value is perfectly
binding, while obviously not concealing.


Usually, commitment schemes consist of two phases:

\begin{itemize}
  \item \emph{commitment phase} -- Alice chooses the value, and produces a proof for Bob
  \item \emph{reveal phase} -- Alice reveals choosen value to Bob, who verifies it using his proof
\end{itemize}

As it turns out, commitment schemes constitute a rich and important branch of cryptography, with lots of
applications both practical and theoretical, as building blocks for other protocols. One simple example,
motivating the need for such device, and showing naturally arising problems it solves, is a game of 
rock-paper-scissor. Two people form one of three shapes with their palm, and simultaneously display it
to one another. Their choices determine the outcome -- one of them wins, or there is a draw. In the
language of commitment schemes, used above, two people commit to one of 3 possible values, and then reveal
their choice. It is vital that neither knows the choice of the other before he makes his own, otherwise
he could always choose a winning shape, and inevitably win every time, rendering the game pointless.
This illustrates the need for concealing -- the choice must be secret. In practice, this is ensured
by forming the shape keeping the hand behind one's back. Furthermore, it must not be possible to change
the value after commitment. Otherwise, after one of the players reveals his choice, the other could again
switch to winning shape. In practice, players reveals their values simultaneously, thus in principle it
should not be possible to cheat.\footnotemark

\footnotetext{
Of course, someone with superhuman reflexes and perception could still manage to switch sufficiently 
fast, so it is, in principle, neither concealing, nor binding -- it's an inherent theoretical security
flow. With a proper commitment scheme, there is no such problem, as long as both players commit to their
choice before the reveal phase.
}


\section{Commitment schemes in modern cryptography}

In this section, we shall explore briefly some of the applications of commitment schemes in various
areas of cryptography, to provide further motivation and emphasize importance of the subject.

\subsection{Zero-knowledge proofs}

Zero-knowledge proof (protocol) is a method of proving some statement without revealing anything more
than what is required to verify the proof. The problem bears resemblance to the commitment problem, but
is more general. Nice introduction to the subject, with motivating examples and precise definitions can
be found in the first two chapters of \cite{MIT:StatZero}. 

Common special case is proving that one possesses some information without revealing it.
One simple example comes from asymmetric cryptography: if Alice posesses the private key matching Bob's
public key, she can prove it to Bob in the following manner: Bob chooses a random string, encrypts it
with the public key, and sends it to Alice, who subseqnently uses her private key to decrypt the message,
and sends the plaintext to Bob. Assuming security of choosen encryption algorithm, Bob can conclude 
with high probability that if the plaintext matches his original encrypted message, Alice does indeed
possess the private key. Furthermore, if Alice does not have the private key, she has no way to obtain
the plaintext, short of breaking the encryption.

Commitment schemes often prove useful as building blocks of zero-knowledge protocols. Well-known example
is a way for Alice to prove she knows the Hamiltonian cycle in certain graph, without revealing the
cycle. Detailed discussion and analysis can be found in the first section of \cite{CM:CryptoNotes}. 
Let \(G\) be the graph. The protocol consists of following steps:

\begin{enumerate}
  \item Alice chooses some graph \(G'\) isomorphic to \(G\) and isomorphism \(\sigma\colon G\cong G'\)
  \item Alice commits to her choice
  \item Bob can now ask Alice for one of two things:
    \begin{enumerate}
      \item graph \(G'\) and isomorphism \(\sigma\)
      \item image of Alice's hamiltonian cycle by \(\sigma\), i.e. hamiltonian cycle in \(G'\)
    \end{enumerate}
  \item Bob verifies the answer, depending on the question
\end{enumerate}

If Alice can consistently produce acceptable responses to Bob's questions, he can conclude with high
probability that she has indeed found the hamiltonian cycle in \(G\). Otherwise, she would either fail
to exhibit isomorphism between \(G\) and her choosen graph \(G'\), even if she knew a hamiltonian
cycle in \(G'\), or she wouldn't be able to find hamiltonian cycle in \(G'\), even if she knew an
isomorphism \(G\cong G'\). At the same time, Bob learns nothing about the cycle in \(G\), since he
either gets the isomorphism and no cycle, or he gets cycle in some graph \(G'\neq G\), but without
full knowledge of \(G'\) and the isomorphism he cannot pull it back to \(G\).
\footnote{Even with full knowledge of \(G'\) he cannot easily find an isomorphism by himself, as no
polynomial algorithm for Graph Isomorphism Problem is known.}


\subsection{Secret sharing}

Secret sharing is a problem of distributing parts of an information (,,secret'') among a group of
entities (,,players''), such that some number of parts, bounded from below, is necessary to 
reconstruct the full information. A vivid example from popular culture is the concept that usage
of mass-destruction weapons, e.g. nuclear missles, requires authorization and ,,launch codes'' of
two people, to increase security and prevent usage by malicious third parties, that might be able
to obtain one part of such ,,secret''.

There are quite a few known approaches, ranging from relatively easy, like Shamir's scheme, where
the secret is a polynomial, and shares are its' values for some arguments (the secret is reconstructed
as a unique interpolation through such points), or Blakley's scheme (secret is a point in euclidean
space, shares are hyperplanes, such that the point is their intersection) \footnotemark, through more
complicated, more general constructions (albeit, perhaps a bit surprisingly, still largely based on linear
algebra over Galois fields), to relatively new non-linear schemes \cite{Beimel01onthe}. For an overview 
of the subject see \cite{SharingSurvey}.

\footnotetext{The principle is actually the same as in Shamir's scheme, since in both cases the
fundamental idea is distributing parts of system of linear equations. There is an important difference,
though -- shares in Shamir's scheme are constant, while in Blakley's scheme they grow linearly with
the number of participants, unless some restrictions on the hyperplanes are placed.}


The variant of the problem where commitment schemes found use is known as verifiable secret sharing.
In the standard formulation, participants are assumed to be honest, and carry out the protocol correctly.
If this is not the case, it becomes critical that players can verify their own and each other's shares'
validity. Possible realization of verifiable secret sharing consists of distributing publicly proofs
(certificates) of the shares, so that each share can be verified by anyone that possesses it. Such
protocols can be used to construct \emph{simultaneous broadcast networks}. See \cite{VerifiableSharing}
for details and example algorithm. 
\footnote{Which, by the way, utilizes the concept of oblivious transfer, discussed in one of the next
sections}

\subsection{Secure multiparty computation}

Closely related to secret sharing is the problem of secure multiparty computation, where participants
want to calculate value of a function for an input constructed from their partial inputs, without
revealing their partial inputs to each other. Canonical example of such situation is the \emph{milionaire
problem}, described in one of the first papers on the subject \cite{Yao}: two milionaires wish to
know which one is richer, but they are reluctant to reveal their net worth. Needless to say, multiparty
computation has many more practical applications, like negotiations, voting or auctions \cite{grigoriev}.

As it turns out, secure computation is feasible for a very large class of functions, as was shown in
\cite{Goldreich87}, where an effective algorithm for creating a secure protocol based on the description
of the computation has been presented. In \cite{Chaum88} another, slightly more general approach has
been proposed. In both cases, commitment schemes are utilized to ensure correctness of computation in
presence of sufficiently small number of malicious participants by means of verifiable secret sharing. 

\subsection{Oblivious transfer}

Oblivious transfer protocol is a way to transmit information from sender to receiver in such a way,
that the sender does not know what precisely did he send, in particular -- if he sent anything at all.
This seemingly weird concept, introduced in \cite{Rabin81}, turns out to be of fundamental importance.

Original context in which it appeared was an algorithm for exchange of secrets: Alice and Bob have some
values, and they want to exchange it, so that no party can withdraw from the protocol after obtaining
the secret of the other, before giving away its' own secret. With certain assumptions, the problem
can be solved with oblivious transfer. The basic idea of the protocol described in \cite{Rabin81} is:

\begin{itemize}
  \item it can fail -- it's possible that after completing the protocol, neither side knows 
    the other's secret
  \item at the end of the protocol, Bob knows whether or not he has obtained Alice's secret
  \item it is assumed that Alice can always find out whether Bob has obtained the secret
  \item Alice knows Bob's secret iff Bob has received her secret
\end{itemize}

The algorithm is not perfect -- in particular, when Alice receives one of the Bob's messages, before
she sends anything important to Bob, she knows Bob's secret with probability \(\frac{1}{2}\). More
important than the algorithm itself, though, is the idea of distributing information without learning
the state of knowledge of the recipient. In particular, secure oblivious transfer protocol is enough
to solve secure multiparty computation problem \cite{Kilian88}. In the classical setting, bit commitment
is strictly weaker primitive than oblivious transfer \cite{Brassard88}. In the quantum setting, however,
bit commitment has been proven sufficient to build secure oblivious transfer protocol 
\cite{Crepeau88,Bennet92,Yao95,Damgard09}.
\footnotemark

\footnotetext{Also, oblivious transfer can be used to create bit commitment protocol, hence these two
problems are equivalent in quantum setting. Sadly, it implies unconditionally secure oblivious transfer
is impossible, as it has been proven there can be no unconditionally secure quantum bit commitment
protocols \cite{Mayers97,Brassard97,Lo98,Chiribella2013}} 


\section{Classical commitment protocols}

In this section, we shall take a brief look at few classical approaches to the commitment problem,
and try to identify their shortcomings. Of course, by no means does the following discussion aim
to be a complete survey of the field. Its sole purpose is to give a general idea what kind of 
techniques are commonly used. For more information, see e.g. \cite{Brassard88,Naor91,Naor98,Damgard02}.

One fundamental issue with all the classical protocols, consisting of simple exchange of messages,
is that they cannot provide perfect, unconditional security to both Bob and Alice. As we shall see,
there are perfectly hiding protocols, and perfectly concealing protocols, but not both. These two
goals seem to be conflicting -- concealing requires ,,weak'' proof, while binding needs it to be
sufficiently ,,strong''.

Without precise mathematical framework it's impossible to provide a rigorous proof, but it's possible 
to give a (more or less) convincing argument. For simplicity, let us consider the case of bit 
commitment, where the commited information is a single bit. Suppose there is such protocol. Commitment 
proof \(c\) is created from some information \(r\), known only to the commiter, and the commited value 
\(v\in\{0,1\}\). That is, \(c=\phi(r,v)\). Since the protocol is perfectly concealing, there must
be \(r'\) such that \(\phi(r,v)=\phi(r',1-v)\), otherwise \(c\) carries full information about \(v\),
and Bob, having unlimited computational resources, can determine \(v\). But then, Alice, having 
unlimited computational resources as well, can find such \(r'\), and during the reveal phase present 
Bob with \(r', 1-v\) instead of \(r, v\), thus changing her commitment.
\footnote{Not to be confused with unconditional security of quantum protocols, discussed later.
Such protocols also cannot exist, unfortunately, but the proof is quite different.}

\subsection{Protocol based on Graph Isomorphism Problem}

Let \(G\) and \(H\) be isomorphic graphs, provided by Bob. Suppose Alice wants to commit to value 0
or 1. To do this, she creates a graph \(F\) isomorphic to \(G\) if her choice is 0, and isomorphic 
to \(H\) otherwise (for example, by randomly permuting the vertices), and presents it to Bob. Later,
if she wants reveal the value and prove she has commited to it (open a commitment), she exhibits 
isomorphism between \(F\) and \(G\) or \(H\), depending on her choice.

Security of this algorithm depends on two assumptions:

\begin{itemize}
  \item it is computationally infeasible for Alice to find isomorphism between the graphs used in the
    protocol
  \item Alice is certain that \(G\) and \(H\) are indeed isomorphic, even though she doesn't know
    the isomorphism
\end{itemize}

First assumption is (almost) enough to provide practical security. Alice cannot cheat, since that would
require finding an isomorphism between \(F\) and one of \(G\), \(H\) different than the one she used to
create \(F\). She cannot create graph such that she knows isomorphisms with both \(G\) and \(H\), since
that would yield an isomorphism between \(G\) and \(H\). Furthermore, Bob, regardless of computational
power, cannot extract any information from \(F\), as it's isomorphic to both \(G\) and \(H\). The only 
way for Bob to cheat is to provide graphs \(G\), \(H\) which are not isomorphic. Then, if he possesses
sufficient resources, he can learn the value of Alice's bit by finding an isomorphism between \(F\) and
one of \(G\), \(H\).

From the above discussion, we can see that if the two assumptions are satisfied, the algorithm is
perfectly concealing (Bob does not gain any information whatsoever), and binding if Alice cannot solve
the graph isomorphism problem.

This is one of the oldest and simplest proposed algorithms, presented as an ,,elementary example'' 
in the original paper that actually defined the notion of commitment scheme \cite{Brassard88}, and 
used it as a primitive to construct zero-knowledge protocols.

\subsection{Protocol based on Discrete Logarithm Problem}

Let \(p\) be a prime number, \(\mathbb{F}_p=\mathbb{Z}/p\mathbb{Z}\). It is well-known that 
\(\mathbb{F}_p\) is a field, and that multiplicative subgroup of a finite field is cyclic, hence it
has a generator. At the beginning of the protocol, Alice and Bob choose \(p\) and \(\alpha\), some
generator of \(\mathbb{F}^*_p\). Let \(u\) be the smallest integer such that \(2^u \nmid p-1\). 
Then, Alice chooses random \(0\leq y < p-1\) such that \(u\)-th bit of \(y\) is equal to the bit
she wishes to commit to\footnotemark, and calculates \(x\equiv \alpha^y \mod p\), which she gives
to Bob as the commitment proof. During the reveal phase, she presents Bob with \(y\).

The algorithm is concealing, assuming Bob does not possess sufficient computational resources to
calculate the discrete logarithm. On the other hand, it's perfectly binding -- since \(\alpha\) is
a generator of \(\mathbb{F}_p\), for any \(x\in\mathbb{F}_p\) there exists unique \(0\leq y < p-1\)
such that \(x\equiv \alpha^y \mod p\), thus Alice cannot change the commited value, regardless
of her computational resources.



\footnotetext{
Concealing property of this algorithm relies on the difficulty of computing discrete logarithm.
However, while obtaining the whole value is infeasible, some bits of the result can be easily 
determined, hence some care must be taken to avoid placing secret bit in this range. See 
\cite{Brassard88} for details and references.
}

\subsection{Protocol based on one-way permutation} 

Another protocol utlizes concept of one-way permutation. Intuitively, it is a easy to compute
bijection \(\sigma\colon \{1\ldots n\}\rightarrow \{1\ldots n\}\), such that calculating the
inverse is computationally infeasible \footnotemark. Let \(\langle a,b\rangle\) denote standard
inner product in \(\mathbb{F}_2^n\), and \(b\in\{0,1\}\) be the value Alice wishes to commit to.
The protocol consists of the following steps:

\footnotetext{This can be made precise. See \cite{Naor98} for details} 

\begin{enumerate}
  \item Alice and Bob choose one-way permutation \(\sigma\colon \mathbb{F}_2^n\rightarrow 
    \mathbb{F}_2^n\)
  \item Alice chooses random vector \(x\in\mathbb{F}_2^n\), and calculates \(y=\sigma(x)\)
  \item Bob chooses \((n-1)\) linearly independent vectors \(h_i\in\mathbb{F}_2^n\), 
    \(i=1,\ldots, n-1\)
  \item Bob sends them to Alice, who computes \(c_i=\langle h_i, y\rangle\) and sends the results to Bob
  \item Solutions to system of equations \(\langle h_i, X\rangle = c_i\) form one-dimensional
    affine subspace of \(\mathbb{F}_2^n\), consisting of two elements, \(y_0\) and \(y_1\). Alice
    and Bob compute these solutions.\footnotemark
  \item Let \(c\) be such that \(y_c = y\). Alice sends to Bob \(d=b\oplus c\)
\end{enumerate}

Reveal phase consists of Alice sending \(b\) and \(x\) to Bob, who computes \(y=f(x)\) and verifies
the data obtained previously from Alice.

Concealing is relatively easy to show, it follows from the fact that regardless of \(b\), distribution
of the information possessed by Bob, i.e. \(h_i\), \(c_i\) and \(d\) is the same. The scheme is thus
perfectly concealing. It is also computationally binding. The proof, however, is rather involved, and 
thus ommited. Details can be found in \cite{Naor98}.


\footnotetext{They need to agree which one is \(y_0\), and which one is \(y_1\). One way to achieve
this is to fix an total order on \(\mathbb{F}_2^n\), e.g. lexicographical, and let \(y_0\) denote the
smaller solution.}

\section{What does the quantum mechanics bring to the table?}

Predictions of quantum mechanics, over the decades, has been considered by many as defying our intuitive
grasp of reality, if not the nature of the universe itself. Principles governing quantum world seem to
strongly deviate from those of the macroscopic world we observe every day, hence it seems concievable
that, given such vastly different rules, certain problems unsolvable in the classical setting, can be
solved within this new framework. Strong connections with information theory are readily apparent -- 
different nature of the information itself (qubit vs classical bit), of its storage (e.g. no-cloning 
theorem), of the measurement process (e.g. wave function collapse), inherent probabilistic aspects --
all of this could be seen as a promise of a new, rich breeding ground for ideas and technologies
capable of achieving things previously deemed impossible. Given the fundamental limitations and flaws
of classical cryptographical protocols, a natural question arises: can quantum mechanics do better?

\subsection*{Success of Quantum Key Distribution}

Possibly the most significant advances in quantum cryptography have been made in the area of Quantum
Key Distribution (QKD). Key distribution is a problem where two parties wish to produce shared secret
key. Probably the most spectacular application of perfectly secure key distribution protocol is the
fact it makes one-time pad encryption (proven by Shannon to be perfectly secure) practically possible.
Classicaly, one-time pad, although of theoretical interest, was not considered usable, since the
key needs to be the same size as the message to be encrypted with it, and still needs to be somehow 
securely transmitted, which does not seem to be significantly easier than transmitting the message
itself.

Nevertheless, unique features of quantum mechanics (namely, destructiveness of measurment process)
allowed  for creating distribution protocols such that any eavesdropping third-party can be detected,
so if the key is compromised, communicating parties are aware of that \cite{bb84}. Although the
theoretical versions of such protocols are proven to be secure, practical considerations facilitate
certain types of attacks (e.g. most proofs assume the information is carried by a single photon,
which is rather technically challenging constraint). Nevertheless, over time more and more refined
protocols have been devised, improving safety and efficiency. It doesn't seem to be an exaggeration 
to say that the state of the art, both theoretical and practical, is impressive.

\subsection*{BCJL protocol}

Success of QKD undoubtedly spurred further research in quantum cryptography. As the solution to the 
problem of bit commitment has been shown to be sufficient for implementation of oblivious transfer
in the quantum setting, it was a ,,valuable target'' \cite{Crepeau88,Bennet92}. First quantum bit
commitment protocol was proposed in 1984 in \cite{bb84}\footnotemark, but had major flaws, allowing
Alice to cheat using EPR effects \cite{bcjl93}. First protocol with claims of provable unconditional
security -- BCJL\footnote{It's introduced in a paper by G. Brassard, C. Cr\'{e}peau, R. Jozsa, 
D. Langlois.} protocol -- appeared in 1993 \cite{bcjl93}.

\footnotetext{It also contains the first quantum key distribution protocol.} 

At this point it might be worthwile to draw a distinction between \emph{perfect} security and
\emph{unconditional} security \cite{Mayers97}. The former requires that Bob obtains absolutely no 
information about Alice's choice whatsoever, and Alice in no way can make Bob believe she has choosen 
value different than the one she has commited to. Due to the nature of quantum mechanics, security 
requirements are usually stated in probabilistic terms -- security in this context means the 
protocol has some ,,security parameter'' \(n\) (in a way, analogue of a ,,key size''), and by increasing
\(n\) it's possible to get arbitrarily close to perfect security in a classical sense. Unconditional
security means that such probabilistic security is completely independent of computational resources
of involved parties -- indeed, they are assumed to possess unlimited power. This is where the
key analogy breaks, as the ,,size of a key'' usually means size of a computational problem necessery
to solve in order to break the scheme, while for unconditionally secure quantum algorithms the
scheme is protected by laws of physics, as opposed to conjectures of complexity theory.

The main idea of the algorithm is that 2 carefully choosen different measurements (orthonormal bases) 
are used, \(\mathcal{B}_1\) and \(\mathcal{B}_2\). The transmission is carried out using \(n\)-bit 
linear code. Alice chooses two vectors, such that their dot product is the bit she wishes to commit and
shows one of the vectors to Bob. The second is transmitted using the quantum channel, using randomly
choosen sequence of bases. Bob randomly chooses bases and measures incoming qubits from Alice. In the
reveal phase, Alice reveals her choice of bases, and second vector, and Bob checks if it matches
the data he received correctly.


Let \(\langle a,b\rangle\) denote standard inner product in \(\mathbb{F}_2^n\), and \(b\in\{0,1\}\) 
be the value Alice wishes to commit to.


\NoCaptionOfAlgo
\begin{algorithm}[H]
\caption{\textbf{Commitment phase}}
Bob chooses suitable \(n\)-bit linear code \(C\) \;
Alice chooses random value \(r\in\mathbb{F}_2^n\) and sends it to Bob \;
Alice chooses codeword \(c\in C\) such that \(\langle r,c\rangle = b\) \;
\For{\(i\in\{1,\ldots,n\}\)}{
  Alice chooses randomly \(B_i\in\{\mathcal{B}_1, \mathcal{B}_2\}\) \;
  So does Bob, he chooses \(B'_i\in\{\mathcal{B}_1, \mathcal{B}_2\}\) \;
  Alice prepares a qubit in state \(c_i\) with respect to basis \(B_i\) \;
  Alice sends it to Bob via the quantum channel \;
  Bob measures the qubit with respect to basis \(B'_i\), obtains result \(c'_i\) \;
}
\end{algorithm}

After the commitment phase, Bob has values \(c'_1,\ldots,c'_n\), roughly \(\frac{3}{4}\) of 
which match Alice's \(c_1,\ldots,c_n\). Linear code \(C\) is choosen such that the amount of
information Bob possesses about actual value of \(c\) is negligible (exponentially small with
respect to \(n\)).

Reveal phase is significantly simpler:

\NoCaptionOfAlgo
\begin{algorithm}[H]
\caption{\textbf{Reveal phase}}
Alice sends \(c\) and \(x\) to Bob \;
Bob computes the value of \(b=\langle r,c\rangle\) \;
Bob calculates total amount of mismatches for all \(i\) such that \(B'_i=B_i\) \;
\eIf{it is sufficiently small} {
  he accepts
}{
  he rejects
}
\end{algorithm}

The original paper contains proofs that all the concievable attack strategies for both Alice
and Bob have vanishingly small probability of success. This part, although not prohibitively
difficult to comprehend, is rather technical and lengthy, so shall not be explored here.
\footnote{As, unfortunately, seems to be the case for most of the remaining proofs. Unlike
some of the classical solutions, quantum cryptography seems to rely on rather delicate, technical
bounds and careful, precise probability estimates, thus does not lend itself to clear exposition
easily.}

\subsection*{Unconditionally secure quantum bit commitment is impossible}

BCJL paper has received a lot of attention, and the existance of unconditionally secure quantum bit
commitment has been used in other papers \cite{Yao95}. Soon, however, doubts began to emerge, and
successful attacks on algorithms previously considered secure have been published, including the
,,proven'' BCJL \cite{Lo96,Mayers96}\footnotemark. The final blow to the dream of achieving unconditionally
secure bit commitment by means of quantum mechanics was delt year later, when D. Mayers \cite{Mayers97}
and H. Lo, H. F. Chau \cite{Lo98} have independently proven that no such scheme exists, generalizing
and extending methods used to bring down BCJL. The result is widely believed to be true, occasional
voices of disagreement (like \cite{Yuen01}) don't seem to impact the opinion of majority. It has
far-reaching consequences -- for example, it shows that no unconditionally secure oblivious transfer
protocol can exists, since it could be used to implement unconditionally secure bit commitment
\cite{Crepeau88}.

\footnotetext{Although, admittedly, it was one of the last to succomb
to insecurity proof -- while Lo and Chau exhibited vulnerabilities in simpler variants, Mayers in
\cite{Mayers96} claims his paper describes the first attack applicable to BCJL itself.}. 

The source of the problem is the well-known EPR effect \cite{EPR}. While  attacks of this nature has
been considered in some other areas of quantum cryptography (e.g. it is remarked as a theoretical,
but technically infeasible, vulnerability of the coin-flipping scheme proposed in \cite{bb84}),
it was not considered in the security proof of BCJL. The impossibility proof relies on an observation
that if the protocol is secure against Bob, then the density matrices describing the state of the
system visible to Bob for both possible Alice's choices must be very close to each other. Then if 
Alice, instead of performing a measurement in the step when she prepares qubits for Bob, decides to
skip it, it is possible for her later to find unitary transformation such that:
\begin{itemize}
  \item it only changes the bits she has access to
  \item if applied to the system describing the whole protocol, it changes it to the state 
    corresponding to different commitment
\end{itemize}

\subsection*{Example}

Purpose of this section is to illustrate the main ideas behind the no-go theorem from the previous
paragraph. It follows closely the simple variant of insecurity proof from \cite{Lo96}. While the actual
general impossibility proof presented in \cite{Mayers97} does not seem to be excessively complicated,
the basic ideas are the same, and so it might be more illuminating to focus on a simpler application.

First, let us propose the general model of bit commitment protocol. Let \(\left\{\Ket{e_i}_A\right\}\),
\(\left\{\Ket{e'_i}_A\right\}\) be two orthonormal bases, and \(\left\{\Ket{\phi_i}_B\right\}\),
\(\left\{\Ket{\phi'_i}_B\right\}\) normalized states, with

\[
\sum_{i=1}^n\alpha_i \Ket{e_i}_A\otimes \Ket{\phi_i}_B=\Ket{0}
\]
\[
\sum_{i=1}^n\beta_i \Ket{e'_i}_A\otimes \Ket{\phi'_i}_B=\Ket{1}
\]
Subscripts stand for \textbf{A}lice and \textbf{B}ob -- each of them has a part of the quantum system. 
Both Alice and Bob know the states \(\left\{\Ket{\phi_i}_B\right\}\), \(\left\{\Ket{\phi'_i}_B\right\}\).

Let \(b\) be the bit Alice wishes to commit to. Commitment phase is carried out in the following
way:

\NoCaptionOfAlgo
\begin{algorithm}[H]
\caption{\textbf{Commitment phase}}
Depending on \(b\), Alice prepares the whole system as above \;
Alice measures her part of the system, and obtains some value \(k\) \;
Alice send to Bob his part of the system \;
\end{algorithm}

\NoCaptionOfAlgo
\begin{algorithm}[H]
\caption{\textbf{Reveal phase}}
Alice sends \(b\) and \(n\) to Bob \;
Bob measures his qubits to verify the correlations implied by data from Alice \;
\end{algorithm}

As it turns out, many proposed protocols can be described as special cases of this scheme 
\cite{Lo96}. For example, in BJCL Bob measures qubits received from Alice immediately, but if we
allow him to store them until the time Alice decides to open the commitment, we get a protocol
that fits the above description.

Crucial observation is that Bob's measurements depend only on the density matrix of his part
of the system, i.e. partial trace over Alice's system. In the ideal case, he should not be able to
get any information, so the partial traces should be equal for both \(b=0\) and \(b=1\) cases:

\[
\rho_B^0\equiv
\operatorname{tr}_A \Ket{0}\Bra{0} = \operatorname{tr}_A \Ket{1}\Bra{1}
\equiv\rho_B^1
\]

Final ingredient is the following theorem (slightly simplified)\cite{Hughston93}: 

\vspace{5mm}

\begin{theorem}(Schmidt polar decomposition) 
Let \(\Ket{\xi}\in\mathcal{H}_A\otimes\mathcal{H}_B\) be normalized, 
\(\dim \mathcal{H}_A=\dim\mathcal{H}_B=n\), let  \(\rho=\Ket{\xi}\Bra{\xi}\)
and \(\rho_A=\operatorname{tr}_B\rho\), \(\rho_B=\operatorname{tr}_A\rho\) be partial traces. Then
\begin{itemize}
  \item \(\rho_A\), \(\rho_B\) have the same eigenvalues \(\left\{\lambda_i\right\}\)
  \item It's possible to express \(\Ket{\xi}\) as 
\[
    \Ket{\xi}=\sum_{i=1}^n\sqrt{\lambda_i}\Ket{\psi_i}\otimes\Ket{\phi_i}
\]
    where \(\left\{\psi_i\right\}\), \(\left\{\phi_i\right\}\) are orthonormal bases consisting of
    eigenvectors of \(\rho_A\) and \(\rho_B\), respectively. One of the bases may be choosen
    arbitrarily.
\end{itemize}
\end{theorem}

\vspace{3mm}

(Easy) proof is ommited. Let us choose orthonormal basis \(\left\{\Ket{\psi_i}\right\}\)
consisting of eigenvectors of \(\rho_B^0\). In view of the above theorem, there exist orthonormal
bases \(\left\{e_i^0\right\}\), \(\left\{e_i^1\right\}\) such that
\[
\Ket{0}=\sum_{i=1}^n\sqrt{\lambda_i}\Ket{e_i^0}_A\otimes\Ket{\psi_i}_B
\]
\[
\Ket{1}=\sum_{i=1}^n\sqrt{\lambda_i}\Ket{e_i^1}_A\otimes\Ket{\psi_i}_B
\]

Let \(\tau\) be a linear transformation defined on the system such that 
\[
\tau\colon\Ket{e_i^0}_A\otimes\Ket{\psi_i}_B \mapsto\Ket{e_i^1}_A\otimes\Ket{\psi_i}_B
\]
It is obviously unitary. As it does not change Bob's part of the system, Alice can apply it 
without Bob's knowledge nor permission, thus effectively transforming system representing \(\Ket{0}\)
to the one representing \(\Ket{1}\). Applying \(\tau^{-1}\) yields the opposite result. Therefore, 
Alice has a strategy to cheat Bob.

The assumption that \(\operatorname{tr}_A \Ket{0}\Bra{0} = \operatorname{tr}_A \Ket{1}\Bra{1}\)
is a simplification. As noted previously, we require only probabilistic security from unconditionally
secure quantum protocols. In most protocols, these density matrices are only approximately equal.
In such case, it's possible to prove Alice has a cheating strategy that succeedes with high 
probability. Details can be found in \cite{Lo96}.

\section{Current areas of research}

While the impossibility proof seems to rules out the possibility of creating unconditionally secure
commitment protocol, it may still be possible to obtain protocols with good properties under some
less restrictive assumptions. So, while the ultimate goal is impossible to achieve, quantum commitment
protocols can still be a huge improvement over the classical solutions. This leads naturally to study
of models with somehow limited adversaries \cite{Damgard05,Wehner08}. Another promising idea is an
attempt to combine quantum mechanics with special relativity \cite{Kent12}.

\subsection{BQSM}

Bounded Quantum Storage Model (BQSM) is a restriction of the standard model with computationally
omnipotent adverseries, in which the amout of \emph{quantum} data that can be stored is bounded by
some fixed constant. No other limitations are imposed, in particular the size of classical storage
is not impaired\footnotemark. 

\footnotetext{
Still, memory limitation has proven a reasonable approach in the classical setting as well. 
Unconditionally secure oblivious transfer protocol has been found, although it was rather impractical, 
and not quite satisfying, due to rather poor bounds on adversary's memory\cite{Cachin98}. Even worse,
the bounds have been proven to be optimal \cite{Dziembowski04}.
}

As it turns out, in this model there exist unconditionally secure protocols for bit commitment, and
oblivious transfer \cite{Damgard05}. Moreover, honest participants need no quantum memory at all. As
stable quantum storate is currently still a major technical challenge, the protocol seems to be of real
practical interest.

Let \(b\) be the value of the bit Alice wishes to commit to, \(n\) be the security parameter,
\(\mathcal{B}_1\) and \(\mathcal{B}_2\) be orthonormal bases as in the description of BCJL.

\NoCaptionOfAlgo
\begin{algorithm}[H]
\caption{\textbf{Commitment phase}}
Bob chooses random \(x, r\in\mathbb{F}_2^n\) \;
Bob sends \(x_i\) in basis \(\mathcal{B}_{r_i}\) to Alice for each \(i\) \;
Alice measures all the qubits in \(\mathcal{B}_b\), obains some \(x'\in\mathbb{F}_2^n\) \;
\end{algorithm}

\NoCaptionOfAlgo
\begin{algorithm}[H]
\caption{\textbf{Reveal phase}}
Alice sends \(b\) and \(x'\) to Bob \;
Bob verifies that \(x_i=x'_i\) for those \(i\) with \(x_i=b\)
\end{algorithm}

It's possible to prove that if the commiter cannot store at least \(n/2\) qubits until the beggining
of reveal phase, the above protocol is perfectly hiding, and binding with arbitrarily high probability.


\subsection{Noisy-storage model}

Another commonly considered restriction, instead of bounding quantum storage size, is to introduce
imperfection. While adversaries are allowed to store unlimited quantum data, the qubits are slightly
distorted. As in the case of BQSM, this model exploits existing technological limitations to create
practically implementable, provably safe protocols.

In \cite{Wehner08} such unconditionally safe oblivious transfer protocol is introduced. While
quantum bit commitment is not explicitly discussed, the result is of interest, since oblivious
transfer can be used to implement secure bit commitment protocol.

\subsection{Relativistic protocols}

Probably the most promising direction of research as of today tries to overcome the limitations
implied by the impossibility theorem by incorporating relativistic effects \cite{Kent99}. This way,
additional constraints can be imposed on the communication between participants, so that the 
aforementioned no-go theorem no longer applies.

While Mayers \cite{Mayers97} does discuss the possibility of using relativistic constraints and argues 
that his proof is applicable to this situation as well, his remarks were later found not to be entirely
correct, as protocols invulnerable to his attack have been devised, even in the classical setting
\cite{Kent99}. While the results of these efforts had significant practical limitations \footnotemark,
more efficient protocols have since been developed \cite{Kent05} and adopted to the quantum setting.

\footnotetext{
In particular, in the first protocol, the amout of communication between parties necessary to
sustain bit commitment was growing exponentially.
}

This area of research seems presently to be quite active. New relativistic quantum bit commitment
protocols \cite{Kent11}, based on new ideas (no-summoning theorem\footnotemark \cite{Mayers13}) 
have been proposed recently. In particular, last year, one of the protocols \cite{Mayers12}, 
with particulary modest quantum resource requirements (nothing beyond the ability to send quantum
states, and immediately carry out individual measurements is required), that has been proven 
unconditionally secure, has been, apparently, successfully implemented \cite{Lunghi14}. It is the
first published report of experimental implementation of secure relativistic quantum bit commitment 
protocol.

\footnotetext{
Like no-cloning theorem, it expresses fundamental constraint on participats' capabilities. Alice
transmits a quantum state to Bob, and then at some further point in spacetime, he is to send it
back with arbitrarily short delay. It is shown that in Minkowski spacetime, it is impossible in
general.
}

\section{Summary}

Quantum bit commitment, while it certainly does not have as impressive track record as quantum key
distribution, seems to have recovered quite well from the initial problems, like the Mayers'
impossibility theorem. New directions of research are found and pursued, and although the wide
adaptation of quantum bit commitment protocols still seems unlikely in the next few years, recent 
results, like \cite{Lunghi14}, inspire confidence that sooner or later, it will most likely become
a practical technology.

\nocite{*}

\bibliographystyle{cs-agh}
\bibliography{bibliography}

\end{document}
